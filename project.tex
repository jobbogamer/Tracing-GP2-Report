\documentclass[authoryearcitations]{UoYCSproject}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning}

\tikzset{
    vertex/.style={circle,draw,minimum size=10mm},
    invisible/.style={minimum size=10mm},
    pre/.style={->,semithick,>=stealth},
    post/.style={<-,semithick,>=stealth},
    bi/.style={-,semithick}
}

\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{framed}

\newenvironment{nscenter}
    {\parskip=0pt\par\nopagebreak\centering}
    {\par\noindent\ignorespacesafterend}

\lstset{
    language=C,
    showstringspaces=false,
    basicstyle=\ttfamily,
    frame=single
}

\author{Joshua Asch}

\title{Tracing and Debugging in GP2}

\date{Date TBC}
\supervisor{Detlef Plump}
\MEng
\wordcount{7856}


\abstract{
The University of York has developed a graph programming language, GP2 (Graph
Programs 2), which has a small IDE. In this project, new features are designed,
implemented, and evaluated which allow users to step through a GP2 program in
the IDE.
}


\begin{document}

\maketitle
\listoffigures
\listoftables

\cleardoublepage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Introduction}
\label{cha:Introduction}

\section{Motivation}
\label{sec:Motivation}

\emph{Introduce the project, explain why the project needs doing}

%==============================================================================

\section{Ethics}
\label{sec:Ethics}

\emph{Discuss the ethical considerations for the project, which there may
not be any at all, if no humans are involved.}

\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Literature Review}
\label{cha:LiteratureReview}

\section{Programming by Graph Transformation}
\label{sec:ProgrammingByGraphTransformation}

\subsection{Graph Programming}
\label{sec:GraphProgramming}

Graph programming involves a series of transformations applied to a graph. The
problem being solved must be redefined in terms of a start graph and an algorithm
represented by graph transformations. The final graph at the end of the algorithm
gives the solution to the problem.

Historically, programming by graph transformation required using a programming
language such as C or Java, implementing data structures to represent graphs, and
directly making modifications to the graph in the program. However, recently some
attempts have been made to create tools for graph programming which abstract away
the representation of the graphs, allowing the programmer to focus on the program itself.

Some of these tools include GROOVE \citep{GROOVE2012}, AGG \citep{ermel1999},
GrGen \citep{GrGen2010}, and, most recently, GP2 \citep{plump2012}. All of these
are domain-specific languages for graph programming which also provide a graphical
interface to describe graphs and transformations.

These kinds of tools take a representation of a graph program, as defined in their
graphical editor, and transform this into a runnable program. This can be implemented
in a number of languages, including Java (in the case of AGG and GROOVE), C\# .NET
(GrGen), or C (GP2). This program can then be executed to find the output graph
generated by the algorithm.

%==============================================================================

\subsection{The GP2 Language}
\label{sec:TheGP2Language}

GP2 (Graph Programs 2) is a programming language developed at the University of
York \citep{plump2012,bak2015}, an updated implementation of the original language,
GP \citep{plump2009}. It is designed for writing programs at a high level, to
perform graph transformations without having to implement data structures to
represent the graphs in more traditional lower level languages such as C.

Programming in GP2 consists of an input graph, known as the \emph{host graph}, a
set of \emph{rules}, and a \emph{program} which defines the order in which to
apply the rules. Running a GP2 program on a host graph produces a new graph as
a result, called the \emph{output graph}.

%------------------------------------------------------------------------------

\subsubsection{Rules}
\label{sec:Rules}

\begin{figure}
    \begin{framed}
    \begin{nscenter}
        \begin{tabular}{l}

            \texttt{link}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}            {};

                \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=of transition]  {};
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2]       {};

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=of transition] {};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1]      {}
                    edge[post] (rhs 1);

            \end{tikzpicture}

            \\

            \texttt{where not edge(1, 2)}

        \end{tabular}
    \end{nscenter}
    \end{framed}
    \caption{A rule in GP2}
    \label{fig:RuleInGP2}
\end{figure}

Rules are the basic building blocks of a GP2 program and are defined by a
left-hand-side (LHS), a right-hand-side (RHS), and optionally a conditional
clause. A rule can be thought of as the definition of a transformation; a subgraph
matching the LHS of the rule is transformed to resemble the RHS. An example of a
GP2 rule is shown in \autoref{fig:RuleInGP2}.

The conditional clause is used to specify additional constraints on the subgraph
matching the LHS. Any match has to both match the LHS and conform to the constraints
defined by the conditional clause.

In a compiled program, a rule is split into two phases. The \emph{match} phase
searches the current graph for a subgraph which matches the LHS of the rule. This must
be an \emph{injective match}, meaning that each item in the LHS must be matched with
exactly one item in the host graph.

In this implementation of GP2, rule matches are chosen determinstically due to the
impracticality of generating all non-deterministic possibilities, which is what GP1 did.
If no match is found for the LHS, the rule is considered \emph{failed}. If a match is
found, the program moves on to the second phase, the \emph{application}.

A rule specifies a number of \emph{interface nodes}, nodes which are present in both
the LHS and the RHS. These interface nodes can be seen in \autoref{fig:RuleInGP2}; they
are the nodes with small numeric identifers below them. During the application phase,
any nodes in the LHS which are \emph{not} interface nodes will be deleted. Similarly,
any non-interface nodes which appear in the RHS will be created. At the end of the
application phase, the subgraph will match the RHS of the rule definition. The new
graph created by the application of this rule, an \emph{intermediate graph}, is then
used as the input to the next part of the program.

In the example in \autoref{fig:RuleInGP2}, the program will search for a subgraph
containing two nodes without an edge connecting them. If a match is found, it will
be transformed to resemble the RHS by adding an edge between the nodes.

%------------------------------------------------------------------------------

\subsubsection{Labels}
\label{sec:Labels}

Nodes and edges in a graph defined in GP2 can also have \emph{labels}. Labels
can be used cosmetically, without affecting the execution of the program, or
they can be included in rules to have the program read and modify labels.

\begin{figure}
    \begin{framed}
    \begin{nscenter}
        \begin{tikzpicture}
            \node (list) {\texttt{list}} {};
            \node (ss1)  [below=1mm of list] {\rotatebox{90}{$\subseteq$}} {};
            \node (atom) [below=1mm of ss1]  {\texttt{atom}} {};
            \node (ss2)  [below left=1mm of atom] {\rotatebox{45}{$\subseteq$}} {};
            \node (ss3)  [below right=1mm of atom] {\rotatebox{135}{$\subseteq$}} {};
            \node (int)  [below left=1mm of ss2] {\texttt{int}} {};
            \node (string) [below right=1mm of ss3] {\texttt{string}} {};
            \node (ss4)  [below=1mm of string] {\rotatebox{90}{$\subseteq$}} {};
            \node (char) [below=1mm of ss4] {\texttt{char}} {};

        \end{tikzpicture}
    \end{nscenter}
    \end{framed}
    \caption{GP2's type hierarchy for labels}
    \label{fig:TypeHierarchy}
\end{figure}

GP2 has a type hierarchy for labels, shown in \autoref{fig:TypeHierarchy}. Labels
can be of any of these five types. An \texttt{atom} consists of a single entity,
either an \texttt{int} or a \texttt{string}. A \texttt{list} is a collection of
zero or more \texttt{atom}s concatenated together; the concatenation is shown using
a colon (\texttt{:}).

Host graphs and the LHS and RHS of rules must be \emph{totally labelled}, meaning
that every node and edge must have a label. If the programmer wishes to use a node
or edge which appears to be unlabelled, they can use the empty list for that label.

Labels behave in two subtly different ways depending on where they are used. In a
graph, a label has a specific value, similar to an integer or string literal in a
convential programming language. When used in a rule, labels can either use literal
values to match nodes with exact label values, or they can use expressions which
can match a range of label values.

When matching a rule involving labels, GP2 finds a variable assignment which
matches the expressions of the labels in the graph. The values in this assignment
are identical when used in the RHS of the rule.

When using labels in a rule, the type of each label must be specified so that GP2
can find an assignment for each one. A rule which specifies a certain label type
can match any label with that type or a more specific type in the type hierarchy.
For example, a rule which contains a label of type \texttt{string} can match a
node which has a \texttt{char} label. The \texttt{list} type will match any label.

\begin{figure}
    \begin{framed}
    \begin{nscenter}
        \begin{tabular}{l}
            
            \texttt{swap(x, y: int)}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}            {};

                \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=of transition]  {\texttt{y}}{};
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2]       {\texttt{x}}{}
                    edge[pre] (lhs 2);

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=of transition] {\texttt{y}}{};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1]      {\texttt{x}}{}
                    edge[post] (rhs 1);

            \end{tikzpicture}

            \\

            \texttt{where x > y}

        \end{tabular}
    \end{nscenter}
    \end{framed}
    \caption{A GP2 rule which uses labels}
    \label{fig:ExampleRuleWithLabels}
\end{figure}

The rule in \autoref{fig:ExampleRuleWithLabels} will only match a pair
of nodes where the labels are both integers, and the value of the source node's
label is greater than the value of the target node's label. This rule
demonstrates both that labels can be used as conditions in the program, and also
that a rule can modify labels. It also shows that labels act like variables when
used in a rule, since the values of \texttt{x} and \texttt{y} are re-used in the
RHS.

%------------------------------------------------------------------------------

\subsubsection{The Dangling Condition}
\label{sec:TheDanglingCondition}

\begin{figure}
\begin{framed}
    \begin{nscenter}
        \begin{tabular}{l}

            \texttt{delete(x, y, z: list)}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}            {};

                \node[vertex] (lhs 3) [label=below:\tiny{\texttt{2}},left=5mm of transition] {\texttt{z}} {};
                \node[vertex] (lhs 2) [left=of lhs 3]                                        {\texttt{y}} {}
                    edge[pre] (lhs 3);
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2]          {\texttt{x}} {}
                    edge[pre] (lhs 2);

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=5mm of transition] {\texttt{x}} {};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1]          {\texttt{z}} {}
                    edge[post] (rhs 1);

            \end{tikzpicture}

            \\\\\\

            \begin{tikzpicture}

                \node (transition) {$\Rightarrow$} {};

                \node[vertex] (lhs c) [left=2.5mm of transition, yshift=-10mm] {\texttt{3}} {};
                \node[vertex] (lhs b) [left=of lhs c]                        {\texttt{2}} {}
                    edge[pre] (lhs c);
                \node[vertex] (lhs a) [left=of lhs b]                        {\texttt{1}} {}
                    edge[pre] (lhs b);
                \node[vertex] (lhs d) [above=of lhs b]                       {\texttt{4}} {}
                    edge[pre] (lhs b);


                \node[vertex]     (rhs a)         [right=2.5mm of transition, yshift=-10mm] {\texttt{1}} {};
                \node[invisible]  (rhs invisible) [right=of rhs a]                                     {};
                \node[vertex]     (rhs c)         [right=of rhs invisible]                {\texttt{3}} {}
                    edge[post]    (rhs a);
                \node[vertex]     (rhs d)         [above=of rhs invisible]                {\texttt{4}} {}
                    edge[pre]     (rhs invisible);

            \end{tikzpicture}

        \end{tabular}
    \end{nscenter}
    \end{framed}
    \caption{Attempting to apply a rule when the match violates the dangling condition}
    \label{fig:FailDanglingCondition}
\end{figure}

There is an additional condition which determines whether a rule can be matched, the
\emph{dangling condition}. This condition states that if a rule causes a node to be
deleted, the rule must also delete all edges incident to that node. In
other words, all non-interface nodes in a rule match must have no incoming or outgoing
edges which are not also part of the match.

\autoref{fig:FailDanglingCondition} shows the result of attempting to apply a rule
where the match violates the dangling condition. Since node 2 is not an interface
node, it is deleted during the application of the \texttt{delete} rule. However, the
rule does not specify that the edge from 4 to 2 should be deleted. This leaves a
\emph{dangling edge} from node 4 with no target. The dangling condition is used to
ensure that rule applications result in no dangling edges.

%------------------------------------------------------------------------------

\subsubsection{Programs}
\label{sec:Programs}

A GP2 program defines the order in which to apply rules using 8 simple control
structures:

\begin{description}
    \item[\textsc{Sequence}]
    Two subprograms separated by a semicolon ``\texttt{P; Q}'' are applied
    one after the other.

    \item[\textsc{Rule Set}]
    Rules in curly braces ``\texttt{\{R$_{\text{1}}$, R$_{\text{2}}$, R$_{\text{3}}$\}}''
    define a set, where exactly one rule from the set is executed, chosen
    non-determinstically from all rules in the set which have a valid match.
    If there are no rules in the set which match, the program fails in the
    same way as if a single rule failed to match.

    \item[\textsc{If-Then-Else}]
    In the statement ``\texttt{if C then P else Q}'', a copy of the graph is taken,
    before executing the sub-program \texttt{C}. The result, i.e. success or failure,
    is then used to determine whether to run \texttt{P} or \texttt{Q}. If C succeeded,
    \texttt{P} is executed on the copy of the original graph. If it failed, then
    \texttt{Q} is executed on the original graph. Note that by taking a copy first,
    any changes made by \texttt{C} are always reverted before executing either
    \texttt{P} or \texttt{Q}.

    \item[\textsc{Try-Then-Else}]
    Similar to \textsc{If-Then-Else}, but \texttt{C} is only reverted if it fails.
    Thus any changes made by \texttt{C} are \emph{not} reverted before executing
    \texttt{P}, but they \emph{are} reverted before executing \texttt{Q}.

    \item[\textsc{As-Long-As-Possible}]
    A subprogram followed by an exclamation point ``\texttt{P!}'' is executed
    repeatedly until it fails. When \texttt{P} fails, the graph is reverted back
    to the last successful state, that is, the state it was in at the end of the
    last successfully applied rule from \texttt{P}.

    The keyword \texttt{break} can also be used to exit from a loop before reaching
    the end. When using \texttt{break}, the graph is \emph{not} reverted before
    continuing with the program.

    \item[\textsc{Procedure}]
    Similar to a C preprocessor macro, a procedure is simply a named subprogram
    where any reference to the procedure name can be replaced with the definition
    of the procedure. Procedures are not allowed to be recursive.

    \item[\textsc{Skip}]
    A no-op which always succeeds, and does not affect the graph. Invoked using the
    keyword ``\texttt{skip}''. This is the same as executing a rule with an empty
    LHS and an empty RHS, which always matches and does nothing to the graph.

    \item[\textsc{Fail}]
    A statement which always fails and does not affect the graph. This is the same
    as attempting to execute a rule for which there are no matches. Invoked using
    the keyword ``\texttt{fail}''. It can also be simulated using an empty
    \textsc{Rule Set} \texttt{\{\}}.

    \item[\textsc{Or}]
    In the statement ''\texttt{P or Q}'', exactly one subprogram, either \texttt{P}
    or \texttt{Q} is chosen non-deterministically and executed. Unlike the
    \textsc{Rule Set} construction, if the chosen subprogram fails, the other is
    \emph{not} applied instead, and the program fails.
\end{description}

For GP2, a subprogram is either a single rule, referenced by its name, or one of
the above control structures. Therefore it is possible to nest control structures
to create more complex programs.

In general, execution of a program continues until either all statements are
executed, or until a statement results in an attempt to apply a rule which has
no matches in the graph. The exceptions to this are \textsc{As-Long-As-Possible}
statements, and the conditional statements in \textsc{If-Then-Else} and
\textsc{Try-Then-Else} structures. In these cases, a failure to match a rule
does not halt execution of the program.

\autoref{fig:ExampleProgramDefinition} shows an example GP2 program, an adapted
version of the program used as a case study in Bak's thesis on GP2 \citep[p.126]{bak2015}.
It is a simple program which determines whether a graph is \emph{2-colourable},
that is, its nodes can be coloured using two different colours without two nodes
of the same colour being connected by an edge. This program requires that the
graph is \emph{connected}, meaning there is an undirected path between every pair
of nodes.

This program consists of four rules and uses many of the constructs outlined
previously, including \textsc{Try-Then-Else}, \textsc{If-Then-Else},
\textsc{Rule Set}s, \textsc{As-Long-As-Possible} and \textsc{Procedure}s.

It also takes advantage of another feature of GP2, the ability to \emph{colour}
a node. The colour of a node is a property which can be set by a rule, or the
host graph can contain coloured nodes. The colour is taken into account when
searching for a rule match; for example, in this program, \texttt{joined\_reds}
will only match when both the nodes' colours are red.

\begin{figure}
\begin{framed}
    \begin{nscenter}
        \begin{verbatim}
Main = try (init; Colour!; if Invalid then fail)
Colour = {colour_blue, colour_red}
Invalid = {joined_reds, joined_blues}
        \end{verbatim}

        \begin{tabular}{l}            

            \texttt{init}

            \\ 

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}                                       {};

                \node[vertex] (lhs) [label=below:\tiny{\texttt{1}},left=2mm of transition]           {};

                \node[vertex] (rhs) [label=below:\tiny{\texttt{1}},right=2mm of transition,fill=red] {};

            \end{tikzpicture}

            \\\\

            \texttt{joined\_reds}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}                                         {};

                \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=2mm of transition,fill=red]  {};
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2,fill=red]       {}
                    edge[pre] (lhs 2);

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=2mm of transition,fill=red] {};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1,fill=red]      {}
                    edge[post] (rhs 1);

            \end{tikzpicture}

            \\\\

            \texttt{joined\_blues}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}                                          {};

                \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=2mm of transition,fill=cyan]  {};
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2,fill=cyan]       {}
                    edge[pre] (lhs 2);

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=2mm of transition,fill=cyan] {};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1,fill=cyan]      {}
                    edge[post] (rhs 1);

            \end{tikzpicture}

            \\\\

            \texttt{colour\_blue}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}                                          {};

                \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=2mm of transition]            {};
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2,fill=red]        {}
                    edge[bi] (lhs 2);

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=2mm of transition,fill=red]  {};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1,fill=cyan]      {}
                    edge[bi] (rhs 1);

            \end{tikzpicture}

            \\\\

            \texttt{colour\_red}

            \\

            \begin{tikzpicture}

                \node         (transition) {$\Rightarrow$}                                          {};

                \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=2mm of transition]            {};
                \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2,fill=cyan]       {}
                    edge[bi] (lhs 2);

                \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=2mm of transition,fill=cyan] {};
                \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1,fill=red]       {}
                    edge[bi] (rhs 1);

            \end{tikzpicture}

        \end{tabular}
    \end{nscenter}
    \end{framed}
    \caption{Definition of 2-colouring in GP2}
    \label{fig:ExampleProgramDefinition}
\end{figure}

\begin{figure}
    \begin{framed}
    \begin{nscenter}
        \begin{tabular}{l}    

            \begin{tikzpicture}
                [vertex/.style={circle,draw,minimum size=10mm}]

                \node (transition1) {$\Rightarrow$} {};

                \node[vertex]  (12) [above left=5mm of transition1] {};
                \node[vertex]  (13) [below=of 12]               {}
                    edge[post] (12);
                \node[vertex]  (11) [left=of 12]                {}
                    edge[pre]  (12);
                \node[vertex]  (14) [below=of 11]               {}
                    edge[post] (11)
                    edge[pre]  (12)
                    edge[post] (13);

                \node[vertex]  (21) [above right=5mm of transition1,fill=red] {};
                \node[vertex]  (22) [right=of 21]                         {}
                    edge[post] (21);
                \node[vertex]  (23) [below=of 22]                         {}
                    edge[post] (22);
                \node[vertex]  (24) [below=of 21]                         {}
                    edge[post] (21)
                    edge[pre]  (22)
                    edge[post] (23);

                \node (transition2) [below right=5mm of 22] {$\Rightarrow$} {};

                \node[vertex]  (31) [above right=5mm of transition2,fill=red] {};
                \node[vertex]  (32) [right=of 31,fill=cyan]               {}
                    edge[post] (31);
                \node[vertex]  (33) [below=of 32]                         {}
                    edge[post] (32);
                \node[vertex]  (34) [below=of 31]                         {}
                    edge[post] (31)
                    edge[pre]  (32)
                    edge[post] (33);

                \node (transition3) [below right=5mm of 34] {$\Downarrow$} {};

                \node[vertex]  (41) [below left=5mm of transition3,fill=red] {};
                \node[vertex]  (42) [right=of 41,fill=cyan]                  {}
                    edge[post] (41);
                \node[vertex]  (43) [below=of 42,fill=red]                   {}
                    edge[post] (42);
                \node[vertex]  (44) [below=of 41]                            {}
                    edge[post] (41)
                    edge[pre]  (42)
                    edge[post] (43);

                \node (transition4) [below left=5mm of 41] {$\Leftarrow$} {};

                \node[vertex]  (52) [above left=5mm of transition4,fill=cyan] {};
                \node[vertex]  (51) [left=of 52,fill=red]                   {}
                    edge[pre]  (52);
                \node[vertex]  (53) [below=of 52,fill=red]                  {}
                    edge[post] (52);
                \node[vertex]  (54) [below=of 51,fill=cyan]                  {}
                    edge[post] (51)
                    edge[pre]  (52)
                    edge[post] (53);

                \node (transition5) [below left=5mm of 51, yshift=2.5mm] {$\xLeftarrow{*}$} {};

                \node[vertex]  (62) [above left=5mm of transition5, yshift=-2.5mm] {};
                \node[vertex]  (61) [left=of 62]                    {}
                    edge[pre]  (62);
                \node[vertex]  (63) [below=of 62]                   {}
                    edge[post] (62);
                \node[vertex]  (64) [below=of 61]                   {}
                    edge[post] (61)
                    edge[pre]  (62)
                    edge[post] (63);

            \end{tikzpicture}

        \end{tabular}
    \end{nscenter}
    \end{framed}
    \caption{Example execution of 2-colouring}
    \label{fig:ExampleProgramExecution}
\end{figure}

An example execution of the 2-colouring program is shown in \autoref{fig:ExampleProgramExecution}.
Starting with an uncoloured graph, the algorithm picks a node and colours it red
using the \texttt{init} rule. It then traverses the graph colouring nodes in
alternating colours using the \texttt{colour\_blue} and \texttt{colour\_red} rules,
by defining them as a \textsc{Rule Set} in a \textsc{Procedure} and executing
it \textsc{As-Long-As-Possible}. When no more uncoloured nodes are present in the
graph, the \texttt{Colour} procedure will be unable to match any further rules,
so it will end.

To check whether the produced colouring is valid, the entire \texttt{Main}
procedure is wrapped in a \textsc{Try-Then-Else} statement. After executing
\texttt{Colour}, the \texttt{Invalid} procedure runs. This procedure uses the
two remaining rules, \texttt{joined\_reds} and \texttt{joined\_blues}, to see if
any adjacent nodes are the same colour. If they are, one of these rules will
match, triggering the conditional statement \texttt{fail} from the
\textsc{If-Then-Else} statement. This in turn causes the outer \texttt{try} to
fail, reverting all changes made to the graph and returning the uncoloured input
graph.

However, if \texttt{Invalid} fails to match either of the rules, it must mean
that no two same-coloured nodes are connected via an edge. This means that it is
a valid colouring. The \texttt{fail} statement is not executed, meaning the
\texttt{try} succeeds. The changes to the graph are kept, and the modified graph
is returned as the result of the program.

In the example execution in \autoref{fig:ExampleProgramExecution}, the host graph
is not 2-colourable. When the rules in \texttt{Colour} can no longer be matched,
\texttt{joined\_blues} inside \texttt{Invalid} will match with the nodes in the
bottom-left and top-right of the graph. Because this rule was successfully applied
(even though it has no effect on the graph), the \textsc{If-Then-Else} causes the
program to enter the fail state. This in turn means that the \textsc{Try-Then-Else}
surrounding the program fails, and all the changes made to the input graph are
reversed. The output graph is therefore identical to the input graph.

%//////////////////////////////////////////////////////////////////////////////

\section{Tracing and Debugging}
\label{sec:TracingAndDebugging}

\subsection{Debugging in Imperative Languages}
\label{sec:DebuggingInImperativeLanguages}

When programming in a high level imperative language, such as C or Java, the
programmer will more often than not have access to a \emph{debugger}. In
\citep{sammet1969}, Sammet says that a program in a high level language without
debugger support may be ''harder to debug than an assembly language which the
programmer understands'', since the programmer has to interpret the compiled code,
rather than reading the source code they wrote.

Most language interpreters and Integrated Development Environments (IDEs) have a
debugger built in \citep{scott2009}, and standalone debuggers are also available
for some languages. For C, this may be \texttt{gdb} \citep{gdbsite}, while for
Java, it might be \texttt{jdb} \citep{jdbsite}. 

A debugger is intended to allow the programmer to pause their program during
execution, so that they can inspect the contents of variables and other memory
locations. It also allows them to run their program step-by-step to see its
execution flow; they may wish to check that a function is called at the expected
point during execution, for instance.

Some debuggers also include more advanced features to make debugging easier and to
give the programmer more insight into their program. Breakpoints are a common feature
which allow the programmer to specify a line of source code and have the program
execute normally until the breakpoint is reached, at which point execution will
pause, or \emph{break}.

Because GP2 has a rule-based structure, unlike imperative programming languages,
it is not clear what a ''line of code'' represents in a GP2 program. The textual
part of a GP2 program can indeed have lines, but since a single line in a GP2
program can be complex and use many rules, this is too high-level to consider a
''line of code'' as a debugger does. In an imperative language, a single line of
code may only perform one or two actions, so inspecting each line individually
shows the flow of the program. In GP2, running a line of the textual program
could result in tens or hundreds of rules being applied if \textsc{As-Long-As-Possible}
is used, for example. It may be inappropriate to focus on how debuggers are
implemented for imperative languages when considering GP2.

%------------------------------------------------------------------------------

\subsubsection{IDEs}
\label{sec:IDEs}

A debugger is often available from within the Integrated Development Environment
(IDE) for a language. For example, the Visual Studio IDE for C, C++, and C\#
includes the Visual Studio Debugger \citep{msdnsite}. One of the most prevalent
Java IDEs, Eclipse, integrates with \texttt{jdb} \citep{eclipsesite}.

When an IDE integrates with a debugger, it can provide additional functionality
by allowing the programmer to interact with the source code and the debugger
visually in the same environment. Visual Studio and Eclipse both allow breakpoints
to be set directly on a line of source code in the editor, for instance. IDEs
often allow the programmer to trace program execution through the source code,
by highlighting each line of code as the programmer steps through in the debugger.

It may be useful to use some of these ideas for GP2. For instance, when stepping
through a GP2 program, it would be helpful to highlight the current statement or
rule being executed, to give the user context.

%------------------------------------------------------------------------------

\subsubsection{Edit-and-Continue}
\label{sec:EditAndContinue}

Edit-and-continue is an even more advanced feature which requires specific
compiler support, and is usually only available in IDEs, since they have access
to both the compiler and the debugger. It allows the programmer to pause execution
of the program, edit the source code, recompile the program, and continue execution
from the previous paused state, without having to restart the program from the
beginning. Edit-and-continue is useful for reducing the time taken to find and
fix bugs, since fixes can be implemented and tested without having to stop and
restart the program's execution.

It is unclear whether edit-and-continue would be a good addition to GP2. On one
hand, it can speed up debugging because the programmer does not have to start the
program again from the beginning. On the other hand, it is not clear how this
feature could be implemented in GP2. It would not make sense for the user to be
able to edit the input graph or an intermediate graph while execution is paused,
because the result of the program would be incorrect. Editing the rules and
program text would make more sense, but this could lead to problems, such as if
the user pauses execution after matching a rule, and then edits that rule in
a way that makes the match incorrect.

%------------------------------------------------------------------------------

\subsubsection{Reverse Debugging}
\label{sec:ReverseDebugging}

\texttt{gdb} supports what is called \emph{reverse debugging} \citep{gdbreversesite}.
This allows program execution to actually be reversed, running the program
backwards to reach an earlier state. This can come in useful to look for
non-deterministic bugs which do not always occur; the program can be run until
the bug occurs, then executed in reverse to look for the cause.

This ability comes with a trade-off, however; running with reverse debugging
enabled reduces the performance of the running program. It can only be used in
specific cases and cannot be enabled all the time, since the program would run
much slower and possibly exhibit time-related bugs. Reverse debugging is also
only available for \texttt{gdb} running on Linux.

\texttt{gdb}'s implementation of reverse debugging involves recording the machine
state after each instruction exectuion, including the values stored in memory and
registers. To reverse an instruction, the state from the previous instruction is
simply restored, making it appear as if the reversed instruction was never
executed. This implementation allows powerful interaction with the program; it
can reverse a single instruction at a time, or it can be run backwards until a
breakpoint is reached. In theory, although \texttt{gdb} does not support this,
this system could allow a form of ''checkpointing'' where execution can be skipped
directly back to an arbitrary point by simply restoring the state from that point.

Reverse debugging may be a useful feature for GP2, because it would allow a
programmer to step backwards through the execution of a GP2 program to inspect
the intermediate graph before and after a rule application, to see what changed.
This method is more akin to tracing than traditional debugging, since the debugger
is storing a history of everything that occurs during execution.

While the implementation of reverse debugging in \texttt{gdb} is limited to the
Linux platform, this is because its implementation requires monitoring calls to
the kernel and system APIs. This is irrelevant to GP2, because it would only
need to trace rule matches and applications, both of which are implemented inside
GP2 itself.

%==============================================================================

\subsection{Tracing in Functional Languages}
\label{sec:TracingInFunctionalLanguages}

The syntax and execution of a GP2 program is very similar to that of a functional
programming language. For example, a function in Haskell is similar to a rule or
set of rules in GP2; the function defines left-hand-sides and right-hand-sides,
and executing it with an argument looks for a LHS which matches the argument,
and returns the RHS. This similarity to the matching and application of rules in
GP2 suggests that it would be appropriate to consider it like a functional
language when implementing debugging or tracing.

Because of the nature of functional languages, it is rare to see traditional
debuggers like those used with imperative languages \citep{wadler1998}. Lazy
evaluation, where the value of a statement is only calculated when it is required,
means that pausing execution on a line of code may not reveal the value of a
statement on that line, because it will not be evaluated until later in the program.

To avoid this problem, functional programmers will often use tracing instead.
This is where additional code is added to the program which simply outputs
information about what the program is doing, either to the console or to a file on
disk. The progammer then reads this information back once the program has finished,
to see what steps the program took and identify where it differed from the
expected execution.

Tracing can be done in primitive ways, by manually adding \texttt{print}
statements to the code, but there are also more sophisticated tools available.
For Haskell, for instance, a handful of different tracing tools are
available \citep{runciman2000}. Two of them, Freja and Hat, are modified Haskell
compilers which add automatic tracing functionality to the compiled program. When
the program runs, trace information is stored in the program heap, which can then
be accessed at the end of execution. The other tool, Hood, is a Haskell library
which is used by importing it and adding \texttt{observe} annotations to the code,
which preserve lazy evaluation and output information about the program as it runs.
The programmer would then inspect the output from the annotations to trace through
the program.

The benefit of compiler based tools like Freja and Hat is the programmer does not
need to think about where to put tracing code, since all code is traced automatically
in the compiled program. However, storing a full trace of an entire program takes
up space either in memory or on disk; the advantage of a manual tool like Hood is
the programmer can reduce the number of trace points to reduce the trace size.

Another disadvantage of Hat is that it has a very large impact on performance,
running more than ten times slower than the original Haskell program \citep{runciman2000}.
Hat adds a lot of overhead at runtime, since the program has to do a lot of
extra work to store the tracing data. On the other hand, Freja is also a tracing
tool, yet Chitil, Runciman, and Koopman state that the overhead is ''not
noticeable''. It is clear that the performance impact of these tools depends on
their implementation.

%==============================================================================

\subsection{Debugging With Other Graph Programming Tools}
\label{sec:DebuggingOtherGraphProgrammingTools}

Each of the three other graph programming tools mentioned in
\autoref{sec:GraphProgramming} have their own debugging or tracing tools.

\subsubsection{AGG}

Of the three tools, AGG has the simplest debugging tools. It allows the user to
select a rule in their graph grammar and then look through all the matches for
that rule, by showing them on the current graph.

A unique feature of AGG is that it also allows the user to manually create a
match; by selecting nodes and edges first in the LHS of the rule, and then in
the graph, the user creates a mapping between the rule and the current graph to
create a match. The tool will alert the user if they attempt to select a mapping
which is not a true match.

When a match has been chosen, either automatically or manually, the rule can then
be applied by clicking a \texttt{Transformation Step} button in the editor. After
a rule has been applied, an \texttt{Undo Step} button becomes available which
reverts the changes made by the most recent rule application.

\subsubsection{GROOVE}

GROOVE also allows the user to inspect all possible rule matches for the current
graph. In the list of rules shown in the editor, the possible matches for each are
shown underneath each rule. These matches can be clicked to highlight them on the
graph, and double-clicking applies the rule, updating the graph.

Similar to AGG, it is possible to undo a single rule application. However, GROOVE
also keeps a history of all previous graph states. In the ''State Space Explorer'',
the tool shows a transition diagram containing all the previously visited graph
states, with the transitions representing the rule applied to reach a given state.
In this view, the user can select a previous state and jump back to it, allowing
the user to undo multiple rule applications at once, or even undoing previous rule
applications and re-applying other rules, in one step.

\subsubsection{GrGen}

GrGen's debugger is different in that it is controlled using a command-line style
interface, rather than using buttons in the editor UI. It provides a command to
apply a single rule, similar to the other two tools.

However, when applying a rule, GrGen can show more detail. It can show the steps
required to apply a rule: the match, the modification to the graph, and the result.
It shows each of these stages individually, highlighting the relevant areas on the
graph at each stage.

Another unique feature of GrGen's debugger is that it allows the user to tell the
program to run until the end of the current loop. GrGen supports a loop structure
similar to GP2's \textsc{As-Long-As-Possible}, and the debugger's \texttt{step out}
command will continue to execute until the current loop ends, giving control back
to the user.

Finally, GrGren also supports a feature similar to breakpoints. It allows the user
to specify a condition, and when that condition is met, execution will pause. One
type of condition which can be specified is a certain modification to the graph,
such as pausing execution when a specific node is deleted from the graph.

%==============================================================================

\subsection{Previous Work on Debugging in GP2}
\label{sec:PreviousWorkOnDebuggingInGP2}

There has been some previous work to add debugging facilities to GP2 \citep{taylor2016}.
This work was focused on modifying the compiler to support stepping through a
program.

In that project, command line arguments were added to allow the user to specify
how big a ''step'' should be, and how many steps to execute before stopping.
This allows GP2 to approximate breakpoints by picking an appropriate step size
and count in order to finish execution at the point the programmer is interested in.

However, there are some problems with this method. For one, once the specified
number of steps have been executed, the program terminates completely and outputs
the current graph. This means that if the programmer wishes to step through the
program one rule at a time, for example, they must run the compiler multiple times
and increase the number of steps by one each time, wasting time by re-executing
earlier steps at each iteration.

Another problem is that, although the compiler was modified, the graphical editor
remains unchanged, and so does not support the new partial execution feature.
For the feature to be most useful, it would have to be integrated into the editor.


\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Requirements}
\label{cha:Requirements}

Before designing and implementing a system, the requirements for the system need
to be considered. These requirements should be based on expected real-world usage
of the tool and keep the goals of the tool in mind.

\section{Potential Users}
\label{sec:Potential Users}

In order to decide what the requirements for a debugging tool are, it is useful
to consider the types of user who would potentially use such a tool. There are
two main potential audiences for a GP2 debugging tool:

\begin{itemize}
    \item Programmers who have written a GP2 program which they would like to
          debug. Either the program produces unexpected output, or it never
          terminates, so the programmer wishes to use the debugging tools to
          understand why their program is behaving incorrectly, and then fix the
          bug.

    \item New users of GP2 who are still learning the language. GP2 is an
          unconvential language and its concepts can be unfamiliar to
          inexperienced users. Allowing these users to step through a GP2
          program would let them see how GP2 works and help them to understand
          the language faster.

          However, it should be noted that the debugger is not a substitute for
          documentation or user manuals; the debugger should not be expected to
          explain the semantics of GP2, but rather act as a tool to show the
          process of running a GP2 program.
\end{itemize}

%//////////////////////////////////////////////////////////////////////////////

\section{Integration and Maintainability}
\label{sec:IntegrationAndMaintainability}

Consideration should also be given to how the new features are integrated into
GP2. The experience of using existing GP2 features should be unaffected, and the
codebase should stay maintainable for future developers of GP2. The high-level
requirements this leads to are:

\begin{itemize}
    \item Backwards compatibility. Adding a debugging tool should not impact the
          existing features of GP2, the compiler, or the IDE. Programs written
          before the addition of debugging tools should still be runnable in the
          new IDE.

    \item Make debugging optional. The user should not be forced to use the
          debugging tools every time they run their program, and should be able
          to choose when to enable them.

    \item Minimise the performance impact. Running a program with debugging tools
          should affect performance as little as possible, and running with
          debugging disabled should have no performance impact compared to the
          previous version of GP2.

    \item Keep the codebase maintainable. When modifying existing code, or adding
          new code, follow conventions and make code readable. Make the intent
          of any changes clear to ensure future developers will understand what
          has been changed.
\end{itemize}

%//////////////////////////////////////////////////////////////////////////////

\section{User Scenarios}
\label{sec:UserScenarios}

To further identify specific low level requirements for the tool, two
hypothetical user scenarios have been created to show potential situations a
user could be in, and how the debugging tools can help the user complete their
task in those situations.

%==============================================================================

\subsection{Experienced GP2 Programmer}

In the first scenario, the user is an experienced GP2 programmer who understands
all the concepts and semantics of GP2. They have written a program similar to
the one shown in \autoref{fig:ExampleProgramDefinition}, to determine whether a
graph is two-colourable.

However, their program is slightly different, and does not output the coloured
graph when it is two-colourable; instead, the original, uncoloured graph is
always returned, and an extra node is added to show the result. If the graph is
two-colourable, a green node is added, otherwise a red node is added. The
program they have written is shown in \autoref{fig:AlternateTwoColourableProgram},
along with the two new rules, \texttt{add\_red\_node} and \texttt{add\_green\_node}.
The other rules are omitted since they are identical to the rules in the
original program.

\begin{figure}
    \begin{framed}
        \begin{nscenter}
            \begin{verbatim}
Main = if (init; Colour!; Invalid)
           then add_red_node
           else add_green_node
Colour = {colour_blue, colour_red}
Invalid = {joined_blues, joined_blues}
            \end{verbatim}

            \begin{tabular}{l @{\hskip 20mm} l}
                \texttt{add\_red\_node} & \texttt{add\_green\_node}
                
                \\

                \begin{tikzpicture}
                    \node         (transition) {$\Rightarrow$}                                           {};
                    \node         (lhs) [left=5mm of transition] {$\varnothing$}                         {};
                    \node[vertex] (rhs) [label=below:\tiny{\texttt{1}},right=5mm of transition,fill=red] {};
                \end{tikzpicture}

                &

                \begin{tikzpicture}
                    \node         (transition) {$\Rightarrow$}                                           {};
                    \node         (lhs) [left=5mm of transition] {$\varnothing$}                         {};
                    \node[vertex] (rhs) [label=below:\tiny{\texttt{1}},right=5mm of transition,fill=green] {};
                \end{tikzpicture}
            \end{tabular}
        \end{nscenter}
    \end{framed}
    \caption{Alternate version of the 2-colourable program}
    \label{fig:AlternateTwoColourableProgram}
\end{figure}

Unfortunately, when they test their program, for some inputs it gives the
incorrect result; for certain non-two-colourable graphs, the program still adds
a green node to indicate that it is two-colourable. Just by inspecting the
program, the user cannot determine what the bug is with the program, so they
decide to use the simplest possible non-two-colourable input graph, shown in
\autoref{fig:SimplestNonTwoColourableGraph}, and use the debugger to step
through their program.

\begin{figure}
    \begin{framed}
        \begin{nscenter}
            \begin{tikzpicture}
                \node[vertex] (top) {};
                \node[vertex] (left) [below=5mm of top, xshift=-10mm] {}
                    edge[pre] (top);
                \node[vertex] (right) [right=10mm of left] {}
                    edge[post] (top)
                    edge[pre] (left);
            \end{tikzpicture}
        \end{nscenter}
    \end{framed}
    \caption{Simplest possible non-two-colourable graph}
    \label{fig:SimplestNonTwoColourableGraph}
\end{figure}

As they step through the program, the \texttt{init} rule colours the top node red,
then \texttt{colour\_blue} is applied, followed by \texttt{colour\_red}. This results
in the graph being coloured red, blue, red running clockwise. Clearly the rules
for colouring nodes are defined correctly, so the bug must be in the error
detection logic.

They continue stepping through the program and it reaches the \texttt{Invalid}
procedure. They use the debugger to highlight a match for \texttt{Invalid}
without applying it, and it turns out there are none, which should not be the
case. They first look at the definitions for the \texttt{joined\_reds} and
\texttt{joined\_blues} rules, and they are definitely correct. Finally they look
at the definition of \texttt{Invalid} itself, and realise they have put
\texttt{joined\_blues} in the rule set twice, so \texttt{joined\_reds} is never
actually used.

The bug in this program was fairly subtle, since the general structure of the
program is mostly correct; there are two rules in \texttt{Invalid} as expected,
but the same rule was added twice. Without the debugger to step through the
program, it may have taken much longer to spot this mistake, since stepping
through allowed the user to see the coloured graph before it was reverted by
the \texttt{if} statement.

The ability to view a match without applying it also helped in this case, since
it allowed the user to see that none of the rules in \texttt{Invalid} matched,
without automatically exiting the \texttt{if} condition when no rules matched.

%==============================================================================

\subsection{New User Learning GP2}

In the second scenario, the user is inexperienced with GP2 and is still trying
to learn the language. They understand most of how the language works, but they
are having trouble with understanding the in semantics of \textsc{If-Then-Else}.

\begin{figure}
    \begin{framed}
        \begin{nscenter}
            \begin{tabular}{l}
                \texttt{Main = if insert then bridge else loop}
                \\\\
                \texttt{insert}
                \\
                \begin{tikzpicture}
                    \node         (transition) {$\Rightarrow$}            {};

                    \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=5mm of transition] {};
                    \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2]          {}
                        edge[pre] (lhs 2);

                    \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=5mm of transition] {};
                    \node[vertex] (rhs 2) [right=of rhs 1]                                        {}
                        edge[post] (rhs 1);
                    \node[vertex] (rhs 3) [label=below:\tiny{\texttt{2}}, right=of rhs 2]         {}
                        edge[post] (rhs 2);
                \end{tikzpicture}
                \\\\
                \texttt{bridge}
                \\
                \begin{tikzpicture}
                   \node         (transition) {$\Rightarrow$}            {};

                    \node[vertex] (lhs 3) [label=below:\tiny{\texttt{3}},left=2.5mm of transition]   {};
                    \node[vertex] (lhs 2) [label=below:\tiny{\texttt{2}},left=of lhs 3]            {}
                        edge[pre] (lhs 3);
                    \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=of lhs 2]            {}
                        edge[pre] (lhs 2);

                    \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=2.5mm of transition]  {};
                    \node[vertex] (rhs 2) [label=below:\tiny{\texttt{2}},right=of rhs 1]           {}
                        edge[post] (rhs 1);
                    \node[vertex] (rhs 3) [label=below:\tiny{\texttt{3}},right=of rhs 2]           {}
                        edge[post] (rhs 2)
                        edge[post,bend right=45] (rhs 1);
                \end{tikzpicture}
                \\\\
                \texttt{loop}
                \\
                \begin{tikzpicture}
                    \node         (transition) {$\Rightarrow$}            {};

                    \node[vertex] (lhs 1) [label=below:\tiny{\texttt{1}},left=5mm of transition] {};

                    \node[vertex] (rhs 1) [label=below:\tiny{\texttt{1}},right=5mm of transition] {}
                        edge [post,loop right] (rhs 1);
                \end{tikzpicture}
                \\\\
                Input graph:
                \\\\
                \begin{tikzpicture}
                    \node[vertex] (node 1) [yshift=5mm]                 {};
                    \node[vertex] (node 2) [right=of node 1] {}
                        edge[post] (node 1);
                \end{tikzpicture}
            \end{tabular}
        \end{nscenter}
    \end{framed}
    \caption{Simple program to learn the semantics of \textsc{If-Then-Else}}
    \label{fig:LearnSemanticsOfIf}
\end{figure}

They have written a very simple GP2 program, shown in \autoref{fig:LearnSemanticsOfIf},
which consists of three rules and a single \textsc{If-Then-Try} statement. When
they run this program on the input graph shown, they incorrectly expect the
output graph to match the RHS of the \texttt{bridge} rule, because they expect
\texttt{insert} to be applied, followed by \texttt{bridge}.

In actuality, this program fails, because the changes made by \texttt{insert}
are reverted before attempting to match \texttt{bridge}, meaning there is no
possible match for \texttt{bridge}.

The result confuses the user, who then decides to use the debugger to step
through the program to see what happened. The first thing they see is the
program tries to match \texttt{insert} and succeeds, which they expected.
However, then they advance to the next execution step and are surprised that
no changes have been made to the graph. They then realise that they had mixed
up the semantics of \textsc{If-Then-Else} and \textsc{Try-Then-Else}.

Ideally in this situation, the debugger would explicitly show that backtracking
will occur once the \texttt{if} condition has been verified. It may also allow
the user to step backwards and forwards over the program so they can make sure
they understand what is happening.

By inspecting the execution of this simple program, the user has successfully
used the debugger to aid their learning; even though the debugger does not
explain the semantics directly, the user can understand how the program works.

%//////////////////////////////////////////////////////////////////////////////

\section{List of Requirements}
\label{sec:ListOfRequirements}

\autoref{tab:SystemRequirements} shows a list of all requirements which have
been identified for the GP2 debugging tool.

\begin{table}[tbp]
    \begin{tabularx}{\linewidth}{|l|X|}
        \hline
        \textbf{ID} & \textbf{Description} \\
        \hline
        1    &  The system must be able to trace execution of a GP2 program. \\ \hline
        1.1  &  The system must be able to apply individual rules, one at a time,
                to step through a program. \\ \hline
        1.2  &  It is desirable for the system to allow the user to step
                backwards through a program. \\ \hline
        1.3  &  It is desirable for the system to execute an entire control sequence
                in one step. \\ \hline

        2    &  The system must have a visual debugging component. \\ \hline
        2.1  &  The system must highlight the rule being applied when stepping
                through a program. \\ \hline
        2.2  &  The system must highlight the next rule match in the graph. \\ \hline
        2.3  &  It is desirable for the system to highlight changes which were
                made as a result of the previously applied rule. \\ \hline
        2.4  &  It is desirable for the system to highlight the current position
                in the textual portion of the program. \\ \hline
        2.5  &  The system must show each intermediate graph in the IDE. \\ \hline

        3    &  The system must allow debugging to be controlled from within the
                GP2 IDE. \\ \hline
        3.1  &  The system must provide a way to advance execution by one step. \\ \hline
        3.2  &  It is desirable for the system to provide a way to backtrack
                execution by one step. \\ \hline
        3.3  &  The system must provide a way to find a match for the next rule,
                but not apply the rule. (See requirement 2.2) \\ \hline
        3.4  &  The system must provide a way to apply a rule for which a match
                has been found but not yet applied. (See requirement 3.4) \\ \hline
        3.5  &  The system must provide a way to run an entire program without
                debugging it. \\ \hline

        4    &  The system must act in a predictable and consistent way during
                each execution of a program. \\ \hline
        4.1  &  The system must produce identical results whether debugging is
                enabled or not. \\ \hline
        4.2  &  The system must be able to load existing projects created before
                the system was modified. \\ \hline
    \end{tabularx}
    \caption{List of system requirements identified for the debugging tool}
    \label{tab:SystemRequirements}
\end{table}

\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Design}
\label{cha:Design}

\emph{Explain the design phase, what was considered, and what ultimately 
became the choice for what to do.}

%//////////////////////////////////////////////////////////////////////////////

\section{Design Considerations}

\subsection{Implementations of GP2}
\label{sec:ImplementationsOfGP2}

There are two implementations of GP2, an interpreter written in Haskell
\citep[ch. 5.3]{bak2015}, and a compiler written in C \citep[ch. 5.5]{bak2015}.
The interpreter is intended to provide a reference for other implementations of
GP2, and for the GP2 developers. The GP2 IDE uses the compiler, not the
interpreter, to run the user's program.

The interpreter may be of some interest, since an interpreter runs ''live'',
moving through the program executing each statement as it is reached. This
behaviour could be exploited to implement a form of debugging, by pausing
execution of the interpreter at various points and outputting the current state
of the program.

To take advantage of the interpreter, the GP2 editor would have to be modified
so that it runs the user's program using the interpreter rather than the compiler.

The other difference between the interpreter and the compiler is that the compiled
program only produces one output for a given input to a program. The interpreter
returns all unique output graphs, up to isomorphism. For debugging purposes, this
may be of interest to the user, since it allows them to see all the possibilities
of their program. To the developer of the debugger, this is a disadvantage, since
the GP2 IDE does not currently support displaying all possible outputs.

Additionally, because the interpreter is only a reference implementation, the
compiler is the implementation intended for most users. If the IDE were to be
changed to run the interpreter for debugging programs, checks would have to be
made to ensure that the interpreter produces identical outputs to a compiled
version of the same program. This may involve adding a ''single-result mode'' to
the interpreter, where only one output graph is produced, instead of all
possibilities. This would require substantial changes to the interpreter.

%==============================================================================

\subsection{Backtracking in the GP2 Compiler}
\label{sec:BacktrackingInTheGP2Compiler}

To support some operations, such as \textsc{If-Then-Else}, the GP2 compiler uses
\emph{backtracking}, where any changes to the graph are reversed \citep[ch. 5.8]{bak2015}.
If the condition in an \textsc{If-Then-Else} structure fails, any changes need
to be reversed before applying the \textsc{Else} subprogram.

This feature of the compiler could be used as part of the debugging features,
by using it to allow the user to step backwards through the program as it runs,
similar to the reverse debugging mentioned in \autoref{sec:ReverseDebugging}. It
would allow the user to see the state of the graph before a certain rule was
applied, for instance.

However, this backtracking is not available at all points in a program's
execution; backtracking code is only added by the compiler if static analysis
shows that it is necessary. For example, since the \textsc{As-Long-As-Possible}
construct cannot fail, the compiler does not add backtracking code for it. The
compiler would have to be modified to add backtracking code to the entire
program.

%------------------------------------------------------------------------------

\subsubsection{Communicating Backtracking to the User}
\label{sec:CommunicatingBacktrackingToTheUser}

When the user is debugging a program which causes backtracking to occur, the
tool must indicate in some way that this has happened. For inexperienced users
especially, if the graph reverts back to a previous state with no explanation,
it could be extremely confusing.

There are multiple ways the debugging tool could communicate backtracking to
the user:

\begin{itemize}
    \item Show a message when backtracking occurs. This is the simplest option,
          which would involve showing a message somewhere in the IDE when the
          graph is reverted. This would explain to the user what has happened,
          although they may still not understand why the backtracking occurred,
          or what previous state was restored.

    \item Highlight the part of the user's program where the backtracking is
          rooted. For instance, if the program contains
          ``\texttt{if r1 then p1 else p2}'' (assuming \texttt{r1} is a rule
          and \texttt{p1} and \texttt{p2} are procedures), ``\texttt{if r1}''
          could be highlighted differently to indicate that it may produce
          backtracking. This would give the user more insight into why the
          backtracking has occurred, although it may still not be clear which
          previous graph state has been restored.

    \item Show the previous state somewhere in the IDE. This method would
          provide the most context. It allows the user to see exactly what will
          happen when backtracking occurs. It could also be combined with the
          previous idea to give additional information. Combining both would
          allow the user to see the cause of the backtracking, and also what 
          changes occurred.
\end{itemize}

%==============================================================================

\subsection{Non-determinism}
\label{sec:Nondeterminism}

While the definition of GP2 includes non-determinism, such as when choosing a
rule from a \textsc{Rule Set}, the implementation of the C compiler is mostly
deterministic. When executing a \textsc{Rule Set}, the generated C program
will always select the first rule in the set which matches, rather than
non-deterministically selecting from all the rules which match. This is shown
in \autoref{lst:RuleSetGeneratedCode}, which shows the code which the compiler
generates for the statement ``\texttt{\{r1, r2, r3\}}''. This code tries each
rule in turn, and stops when it finds the first one which has a match.

\begin{lstlisting}[
    caption=Generated code for a \textsc{Rule Set} structure,
    label=lst:RuleSetGeneratedCode
]
do
{
  if(matchMain_r1(M_Main_r1))
  {
    applyMain_r1(M_Main_r1, false);
    success = true;
    break;
  }
  if(matchMain_r2(M_Main_r2))
  {
    applyMain_r2(M_Main_r2, false);
    success = true;
    break;
  }
  if(matchMain_r3(M_Main_r3))
  {
    applyMain_r3(M_Main_r3, false);
    success = true;
  }
  else
  {
    ...
    // Failure handling omitted for brevity
  }
} while(false);
\end{lstlisting}

If a user is familiar with the GP2 specification, they may expect their program
to run non-deterministically. They may also expect features in the debugger
related to this non-determinism, such as showing all the possible matches for
a rule, or showing all the matching rules in a \textsc{Rule Set}. However,
because the code for a \textsc{Rule Set} does not attempt to match any other
rules once a match is found, the debugger cannot show all matching rules.
Enabling this would require modifying the compiler to find all matches before
picking one, even if it still always picked the first match.

The exception to this is the \textsc{Or} statement. In the GP2 compiler, this
statement does not always choose the same option, but instead uses the
\texttt{rand()} function to randomly choose between the two possibilities.
This seems to act counter to requirement 4 for the debugger, which states
that the system must be predictable, because on each execution of the program,
it is random whether the first option or second option will be chosen.

However, the debugger cannot take responsibility for how the user's program
is structured. \autoref{lst:OrStatementAnalogy} shows plain C code which is
analagous to a GP2 \textsc{Or} statement, which randomly calls one of two
functions based on a random number. A C programmer would not expect the
debugger to always follow the same execution path when debugging this code,
so it is reasonable to take the same approach with a GP2 debugger.

\begin{lstlisting}[
    caption=C code analagous to GP2's \textsc{Or} statement,
    label=lst:OrStatementAnalogy
]
int random = rand();
if ((random % 2) == 0) {
    someFunction();
}
else {
    someOtherFunction();
}
\end{lstlisting}

In a similar vein, the order of rules within a \textsc{Rule Set} can affect the
execution of a program, since the first matching rule is always applied, as
discussed previously. This means that if the user edits their program and
re-orders the rules in a \textsc{Rule Set}, their program may give different
results. Again, this issue is due to the structure of the program, which the
debugger cannot take responsibility for.

%==============================================================================

\subsection{Program Representation}
\label{sec:ProgramRepresentation}

When a user creates a graph using the visual editor in the IDE, the graph must
be converted to a text based format in order to compile and run the GP2 program.
Depending on the position of elements in the editor, isomorphic graphs may be
converted to different textual representations, with the nodes and edges listed
in a different order, for example.

This is relevant to the debugger because when running a program, the order of
nodes and edges will affect which matches are selected when applying a rule. If
the user runs their program and then rearranges the nodes in the editor, running
the program again may give a different result graph. This would be surprising to
a user, since they did not modify the structure of the graph, only its layout.

Without modifying the algorithm for converting a graph to the text based
representation, it is not possible to avoid the problem. It may be
useful to warn the user if the representation of their graph changes, so that
they are aware it may give different results.

%//////////////////////////////////////////////////////////////////////////////

\section{Proposed Solutions}
\label{sec:ProposedSolutions}

Two different possible high-level designs are outlined below, along with the
advantages and disadvantages of each.

%==============================================================================

\subsection{Modify Compiler to Run Partial Programs}
\label{sec:ProposedDesign1}

Following a similar method to the previous work on adding debugging to GP2
\citep{taylor2016}, the compiler would be modified so that it can run part of a
program and stop, giving intermediate results. The IDE would interact with the
compiler to control how much of the program to run, and to display the
intermediate graphs to the user.

The IDE would have two modes for running a program. The first mode would act
exactly as the current version of the IDE, running the entire program and
displaying the result. No changes would need to be made to the IDE for this mode.

The second mode would be for debugging the program, and would provide the user
with controls to step through their program. Each time a step is taken, the
compiler would be invoked on the most recent intermediate graph, solving the
problem from the previous project of having to re-run the first steps. To
enable this, the output must also include some reference to the point which has
been reached in the program, in order to continue from the same point next time.

%------------------------------------------------------------------------------

\subsubsection{Advantages}
\label{sec:ProposedDesign1Advantages}

\begin{itemize}
    \item Similar work to this has already been done, so implementing this
          design would be an extension of that rather than a new solution
          created from scratch.

    \item Non-terminating or long-running programs do not have to be run in their
          entirety, saving the user time when debugging a program, since they do
          not have to wait for execution to finish.

    \item As shown in the previous project, it is possible to implement partial
          execution in the compiler without affecting compilation or runtime
          performance. It is likely that the tracing method would impact runtime
          performance in some way.
\end{itemize}

%------------------------------------------------------------------------------

\subsubsection{Disadvantages}
\label{sec:ProposedDesign1Disadvantages}

\begin{itemize}
    \item It would be difficult to allow the user to step backwards through the
          program with this method, because each invocation of the compiler
          would be separate, meaning the use of backtracking would be impossible,
          and if the output is simply a graph and the current position in the
          program, there is no way to discover what changes were made to the graph
          during the last invocation.

    \item Continuing from a partially executed state would be impossible if the
          user edits their program or the input graph before continuing. While
          this would be an error on the user's part, it could potentially be
          confusing if they edit the program to fix a bug and then click continue
          instead of restarting from the beginning.

    \item Adding various granularity options for partial execution would require
          adding many new command line arguments to the compiler. Having a lot
          of command line arguments related to debugging may confuse users, and
          could also lead to potential bugs when using these arguments
          programmatically from the IDE.
\end{itemize}

%==============================================================================

\subsection{Use Tracing to Step Through Execution History}
\label{sec:ProposedDesign2}

Instead of pausing execution to show the current state of the program, this
method would instead add tracing to the user's program, and the IDE would run
the entire program before stepping through the history. This is similar to how
tools such as Hat (discussed in \autoref{sec:TracingInFunctionalLanguages}) work.

The existing way of running a program in the IDE would remain unchanged, and
would not enable tracing, to avoid any performance impact of having tracing
turned on. A second button in the UI would run the program with tracing turned
on, and then switch the IDE into a mode which allows the user to examine the
execution history of their program.

%------------------------------------------------------------------------------

\subsubsection{Advantages}
\label{sec:ProposedDesign2Advantages}

\begin{itemize}
    \item It would be possible to add the ability to jump to any point in the
          program's execution, since all states would be stored. Using the other
          proposed method, jumping to a specific point would involve running the
          program and somehow detecting when the requested state is reached.

    \item Stepping through a program would be much faster than using partial
          execution because another process does not have to be executed at each
          step.

    \item Debugging would not be dependent on the compiler, once the programs has
          been compiled and run, so certain additional debugging features could
          be added to the IDE without requiring the compiler to be updated. 
\end{itemize}

%------------------------------------------------------------------------------

\subsubsection{Disadvantages}
\label{sec:ProposedDesign2Disadvantages}

\begin{itemize}
    \item Debugging a non-terminating program may be impossible because the
          program may never output a trace, unless the compiler can be modified
          to produce programs which terminate upon receiving a signal, and save
          their trace before exiting.

    \item Storing a trace may use a lot of memory or disk space, depending on
          the implementation.

    \item It would not be possible to add the ability for a user to choose a
          rule to apply, or a match to apply a rule to, since execution has
          already finished when the user regains control.
\end{itemize}

%==============================================================================

\section{Chosen Solution}
\label{sec:ChosenSolution}

The second solution, tracing a program and then allowing the user to step through
the execution history, has been selected as the chosen design to implement
debugging features in GP2.

This solution has advantages over the other design, such as the ability to
more easily implement more program traversal methods, including backwards
stepping and jumping to a specific point in time. Each step through the trace
will also be much faster that the other design; the IDE does not have to wait
for the program to run a step and return the results, because the program has
already been run.

Another advantage of this design is that it can also help the problem of debugging
a program which uses the \textsc{Or} statement. Since the trace can be used
repeatedly once the program has finished running, the user can step through the
program multiple times without having to re-run the program. This means that 
the branch chosen when stepping through the \textsc{Or} statement will remain
constant until the user edits the program and has to run it again.

The solution also has trade-offs, such as a possible impact on runtime
performance; extra work needs to be done to store the trace. Runtime performance,
while one of the requirements outlined in \autoref{sec:ListOfRequirements},
is less important than the user's ability to actually debug their program. For
the same reason that IDEs such as Visual Studio disable compiler optimisation
by default when debugging, an accurate debugger is more useful than a higher
performance one.

A lot of memory and disk space is available on modern hardware; it is unlikely
that a GP2 trace would exhaust the available resources on a relatively recent
machine. In addition, the GP2 IDE is not currently distributed outside of the
University of York, meaning that the target hardware is mostly the university
hardware, which is designed to have a large amount of both RAM and hard disk
space available.

Additionally, a trace format will need to be designed and implemented so that
the program and the IDE can communicate. This will be a simple Domain-Specific
Language (DSL) which represents the actions a GP2 program takes. Part of this
format can be based on the existing DSL which defines the machine readable 
format of graphs and programs in GP2.

Finally, although the other proposed design would have trivially allowed
non-terminating programs to be debugged, this design does not have a clear
solution to this problem. It is more difficult to support non-terminating
programs with tracing, since as first glance it appears the program has to
finish running before it can output a trace. However, it is possible to get
around this by, for example, periodically writing a partial trace to disk. Then,
if the program is non-terminating and needs to be killed, the user will still
be able to trace through the earlier part of the execution and be able to debug
their program.

\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Implementation}
\label{cha:Implementation}

\emph{What has changed in the GP2 compiler and in the editor, and how does this
implement debugging or tracing for the end user?}

\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Evaluation}
\label{cha:Evaluation}

\section{Requirements Tracing}
\label{sec:RequirementsTracing}

\emph{Go back and compare the implemented debugging tools to the requirements
from \autoref{cha:Requirements}.}

%//////////////////////////////////////////////////////////////////////////////

\section{Performance}
\label{sec:Performance}

\emph{Test the performance of some GP2 alogrithms with tracing turned on and off.}

%//////////////////////////////////////////////////////////////////////////////

\section{User Feedback}
\label{sec:UserFeedback}

\emph{(If there's time) Get some users to use the new features and get feedback
from them.}

\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\chapter{Conclusions}
\label{cha:Conclusions}

\emph{Summary of what has been achieved in the project.}

%//////////////////////////////////////////////////////////////////////////////

\section{Future Work}
\label{sec:FutureWork}

\emph{What's missing (e.g. what requirements weren't met) and what other
improvements could be made by someone else?}

\clearpage

%XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\bibliography{references}

\end{document}
